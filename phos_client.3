.\" Copyright (c) 2021 Omar Polo <op@omarpolo.com>
.\"
.\" Permission to use, copy, modify, and distribute this software for any
.\" purpose with or without fee is hereby granted, provided that the above
.\" copyright notice and this permission notice appear in all copies.
.\"
.\" THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
.\" WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
.\" MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
.\" ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
.\" WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
.\" ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
.\" OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
.Dd $Mdocdate: April 6 2021$
.Dt PHOS_CLIENT_NEW 3
.Os
.Sh NAME
.Nm phos_client_new ,
.Nm phos_client_init ,
.Nm phos_client_set_io ,
.Nm phos_client_req ,
.Nm phos_client_req_uri ,
.Nm phos_client_run ,
.Nm phos_client_run_async ,
.Nm phos_client_fd ,
.Nm phos_client_state ,
.Nm phos_client_rescode ,
.Nm phos_client_resmeta ,
.Nm phos_client_buf ,
.Nm phos_client_bufsize ,
.Nm phos_client_abort ,
.Nm phos_client_close ,
.Nm phos_client_del ,
.Nm phos_client_free
.Nd asynchronous Gemini client functions
.Sh SYNOPSIS
.In phos.h
.Ft struct phos_client *
.Fn phos_client_new "void"
.Ft int
.Fn phos_client_init "struct phos_client *client"
.Ft void
.Fn phos_client_set_io "struct phos_client *client" "struct phos_tls *io"
.Ft int
.Fn phos_client_req "struct phos_client *client" "const char *hostname" "const char *port" "const char *rawreq"
.Ft int
.Fn phos_client_req_uri "struct phos_client *client" "struct phos_uri *uri"
.Ft int
.Fn phos_client_run "struct phos_client *client"
.Ft int
.Fn phos_client_run_sync "struct phos_client *client"
.Ft int
.Fn phos_client_fd "struct phos_client *client"
.Ft enum phos_client_state
.Fn phos_client_state "struct phos_client *client"
.Ft int
.Fn phos_client_rescode "struct phos_client *client"
.Ft const char *
.Fn phos_client_resmeta "struct phos_client *client"
.Ft const char *
.Fn phos_client_buf "struct phos_client *client"
.Ft size_t
.Fn phos_client_bufsize "struct phos_client *client"
.Ft int
.Fn phos_client_abort "struct phos_client *client"
.Ft int
.Fn phos_client_close "struct phos_client *client"
.Ft int
.Fn phos_client_del "struct phos_client *client"
.Ft void
.Fn phos_client_free "struct phos_client *client"
.Sh DESCRIPTION
The
.Nm phos_client
functions provide a simple interface to perform asynchronous Gemini
transaction as clients.
.Pp
The principle of operation is as follows:
A client gets initialised, via either
.Fn phos_client_new
or
.Fn phos_client_init ,
then a request is created using either
.Fn phos_client_req
or its wrapper
.Fn phos_client_req_uri .
A client is fundamentally a state machine:
creating a request initialise it, then
.Fn phos_client_run
or
.Fn phos_client_run_sync
are used to run the state machine.
.Pp
A running request on a client can be stopped at any time using
.Fn phos_client_abort
but then the state machine needs to be advanced anyway until
completion, because the TLS layer may need to be closed.
.Pp
The functions
.Fn phos_client_fd ,
.Fn phos_client_state ,
.Fn phos_client_rescode ,
.Fn phos_client_resmeta ,
.Fn phos_client_buf
and
.Fn phos_client_bufsize
are simple accessors for the relative fields in the
.Vt struct phos_client
to make it easier to create bindings for other languages.
.Pp
A
.Vt struct phos_client
looks like this
.Bd -literal -offset indent
struct phos_client {
	/* internals */
	void			*tls;
	struct phos_tls		*io;
	void			*resolver;
	char			 host[NI_MAXHOST+1];
	char			 port[NI_MAXSERV+1];
	char			 buf[1030];
	size_t			 off;

	int			 fd;
	enum phos_client_state	 state;

	int			 io_err;
	int			 proto_err;
	int			 gai_errno;
	int			 c_errno;

	int			 code;
	char			*meta;
};
.Ed
.Pp
Conceptually, a client is a state machine that goes through the
following states
.Bl -tag -width PCS_POST_HANDSHAKE
.It Dv PCS_START
The default state.
.It Dv PCS_RESOLUTION
On systems that have a way to do asynchronous DNS lookups, a client is
in this state during the domain name resolution.
.It Dv PCS_CONNECT
The client is trying to establish a connection to the remote host.
.It Dv PCS_HANDSHAKE
The TLS handshake is ongoing.
.It Dv PCS_POST_HANDSHAKE
The TLS handshake was successful, it's the right time to check for the
remote peer certificate.
.It Dv PCS_WRITING_REQ
The client is sending the request.
.It Dv PCS_READING_HEADER
The client is reading the server reply.
.It Dv PCS_REPLY_READY
The response was received successfully.
It's safe to read the response code and meta, using the
.Va code
and
.Va meta
field, or the
.Fn phos_client_rescode
and
.Fn phos_client_resmeta
functions.
.It Dv PCS_BODY
A chunk of the server reply can be read.
The buffer is stored in the
.Va buf
field of the
.Vt phos_client
struct, and its length is in the
.Va off
field.
This information can be obtained also via
.Fn phos_client_buf
and
.Fn phos_client_bufsize .
.It Dv PCS_CLOSING
Shutting down the TLS client.
.It Dv PCS_EOF
The transaction was completed.
.It Dv PCS_ERROR
An error happened.
.El
.Pp
After a request has been done, its data should be freed using
.Fn phos_client_close .
After that, a new request can be placed on the very same
.Vt struct phos_client .
.Sh RUNNING THE STATE MACHINE
There are two function that are responsible of running the state
machine.
.Fa phos_client_run
runs a tick and then returns.
Its return value can indicate an error condition, the end of the
Gemini transaction or the condition that must be fullfilled to advance
the state machine (i.e. the socket ready for writing or reading.)
Depending on the network condition, the server software and other
details, a single state can, and usually will, last for a few
iterations.
.Fa phos_client_run_sync
is the blocking counterpart.
It's guaranteed to return only one time per state (exception being
.Dv PCS_BODY
for obvious reason)
and doesn't ask for reading or writing condition on the socket.
.Sh ERROR HANDLING
When an error occurs the client switches immediately to the
.Dv PCS_ERROR
state.
At the moment, it's not exactly straightforward to access the error
information (sorry!)
.Pp
One should first check the
.Va io_err
field in the client: if it's non-zero then a TLS error occurred.
Then
.Va proto_err
should be checked: if it's non-zero then a protocol violation happened
(e.g. a malformed reply from the server).
The
.Va gai_errno ,
if non-zero, indicates an error in the DNS resolution.
Finally, a non-zero
.Va c_errno
indicate an error from the C standard library, usually
.Er ENOMEM .
.Sh RETURN VALUES
.Fn phos_client_new
returns a pointer to a newly allocated client or NULL on error.
.Pp
.Fn phos_client_init ,
.Fn phos_client_req ,
.Fn phos_client_req_uri ,
.Fn phos_client_abort ,
.Fn phos_client_close
and
.Fn phos_client_del
returns 0 on success and -1 on failure.
.Pp
.Fn phos_client_run
returns 0 on EOF, -1 on failure or
.Dv PHOS_WANT_WRITE
or
.Dv PHOS_WANT_READ
to indicate that the underlying file descriptor needs to be readable
or writeable in order to continue; any other value means that
.Fn phos_client_run
should be called again immediately.
.Pp
.Fn phos_client_run_sync
return 0 on EOF, -1 on failure or 1 otherwise.
.Pp
.Fn phos_client_fd
returns the underlying file descriptor, or -1.
.Pp
.Fn phos_client_state
returns the current client state.
.Pp
.Fn phos_client_rescode
and
.Fn phos_client_resmeta
returns the status code and the
.Dq meta
line of the reply if it has been read, 0 and NULL respectively
otherwise.
.Pp
.Fn phos_client_buf
and
.Fn phos_client_bufsize
returns the buffer and its size.
A size of 0 doesn't mean an end-of-file condition.
.Sh SEE ALSO
.Xr phos_server 3 ,
.Xr phos_tls 3 ,
.Xr phos_uri 3
.Sh AUTHORS
.An Omar Polo Aq Mt phos@omarpolo.com
